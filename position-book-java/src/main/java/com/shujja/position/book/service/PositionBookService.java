package com.shujja.position.book.service;

import com.shujja.position.book.model.Action;
import com.shujja.position.book.model.Position;
import com.shujja.position.book.model.TradeEvent;
import com.shujja.position.book.store.InMemoryRepository;
import org.springframework.stereotype.Service;
import java.util.List;

@Service
public class PositionBookService {

    private final InMemoryRepository repository;

    public PositionBookService(InMemoryRepository repository) {
        this.repository = repository;
    }

    public List<Position> processEvents(List<TradeEvent> events) {
        for (TradeEvent event : events) {
            validate(event);
            apply(event);
        }
        return repository.getAllPositions();
    }

    public List<Position> getAllPositions() {
        return repository.getAllPositions();
    }

    private void validate(TradeEvent event) {
        Action action = event.getAction();
        if (action == null) {
            throw new IllegalArgumentException("Action is required");
        }

        if (action == Action.CANCEL && event.getId() == null) {
            throw new IllegalArgumentException("CANCEL event must provide an ID");
        }
        if ((action == Action.BUY || action == Action.SELL) && event.getId() != null) {
            throw new IllegalArgumentException("BUY/SELL IDs must be null — generated by server");
        }

        // BUY/SELL logic
        if (action != Action.CANCEL) {
            if (event.getAccount().isBlank()) {
                throw new IllegalArgumentException("Account is required for BUY/SELL");
            }
            if (event.getSecurity().isBlank()) {
                throw new IllegalArgumentException("Security is required for BUY/SELL");
            }
            if (event.getQuantity() <= 0) {
                throw new IllegalArgumentException("Quantity must be > 0 for BUY/SELL");
            }
        }

        // CANCEL logic checks
        if (action == Action.CANCEL) {
            TradeEvent original = repository.getEventById(event.getId());
            if (original == null) {
                throw new IllegalArgumentException("No event found with ID: " + event.getId());
            }
            if (original.getAction() == Action.CANCEL) {
                throw new IllegalArgumentException("Cannot CANCEL a CANCEL event");
            }
            if (repository.isAlreadyCanceled(event.getId())) {
                throw new IllegalArgumentException("Event ID " + event.getId() + " was already canceled");
            }
            // match account/security
            if (!original.getAccount().equals(event.getAccount())
                    || !original.getSecurity().equals(event.getSecurity())) {
                throw new IllegalArgumentException("CANCEL must match original account/security");
            }
            // negative‐check
            Position pos = repository.getPositionByKey(event.getAccount(), event.getSecurity());
            if (pos == null) {
                throw new IllegalArgumentException("No position found when checking CANCEL");
            }
            int newQty = pos.getQuantity() + (original.getAction() == Action.BUY
                    ? -original.getQuantity()
                    : original.getQuantity());
            if (newQty < 0) {
                throw new IllegalArgumentException("Canceling ID " + event.getId() +
                        " would produce negative quantity");
            }
        }

        // SELL negative‐check
        if (action == Action.SELL) {
            Position pos = repository.getPositionByKey(event.getAccount(), event.getSecurity());
            if (pos == null || pos.getQuantity() < event.getQuantity()) {
                throw new IllegalArgumentException("Insufficient quantity to SELL");
            }
        }
    }

    private void apply(TradeEvent event) {
        if (event.getAction() == Action.CANCEL) {
            repository.cancelEvent(event.getId());
        } else {
            int delta = (event.getAction() == Action.BUY)
                    ? event.getQuantity()
                    : -event.getQuantity();
            repository.addEvent(event, delta);
        }
    }
}
